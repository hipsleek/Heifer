<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- stop google thinking this page is in spanish -->
    <meta name="google" content="notranslate" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ESL Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <style>
      /* layout taken from https://github.com/mwillsey/egg-smol */
      body {
        margin: 0;
        display: flex;
        height: 100vh;
        width: 100vw;
      }

      #editor {
        width: 60%;
        resize: horizontal;
        overflow: auto;
        padding: 5px;
      }

      /* someday */
      /* #editor .CodeMirror { */
      #editor #input {
        width: 97%;
        height: 97%;

        /* disable all textarea styling */
        border: none;
        overflow: auto;
        outline: none;
        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;
        resize: none;
      }

      #panel {
        padding: 10px;
        flex: 1 1 0;
        border-left: 2px solid gray;

        display: flex;
        flex-flow: column;

        /* this size causes no resizing of the output div when the output lines get long. */
        /* an alternative is break-all, see below */
        /* max-width: 37%; */
      }

      #toolbar button {
        margin-right: 5px;
      }

      #output {
        font-family: monospace;
        margin-top: 10px;
        flex-grow: 1;
        white-space: pre-wrap;
        overflow-y: scroll;
      }

      .output-error {
        /* color: red; */
        background-color: red;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-ok {
        /* color: green; */
        background-color: green;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-line {
        overflow-wrap: anywhere;
        /* overflow-wrap: break-word; */
        /* background: white; */
        min-height: 1em;
        line-height: 1;
      }

      /* .output-line:hover {
        background: lightblue;
      } */
    </style>
  </head>

  <body>
    <div id="editor"></div>
    <!-- <div id="editor">
      <textarea id="input" spellcheck="false"></textarea>
    </div> -->
    <div id="panel">
      <div id="toolbar">
        <button id="run-btn" disabled onclick="run()">Run</button>
        <select
          name="examples"
          id="examples"
          onchange="load_selected_example()"
        >
          <option
            value="hello"
            data-text="effect Eff : unit

let test ()
(*@ ex i z ret;
  Eff(i->0, ret);
  req i-> z;
  Norm(i->z+1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in
  let ret = perform Eff in
  i := !i + 1;
  ret"
          >
            Hello world
          </option>
          <option value=src/examples/applyN.ml data-text="let rec applyN_unfolded f x n
(*@ Norm(n=0/\emp, x) \/
  req n>0/\emp; ex r2; f(x, r2); ex r1; applyN_unfolded(f, r2, n-1, r1); Norm(emp, r1) @*)
= if n = 0 then x
  else let r = f x in applyN_unfolded f r (n-1)

let rec applyN f x n =
  if n = 0 then x
  else let r = f x in applyN f r (n-1)

let incr x = x + 1

let unsound_false ()
(*@ Norm(emp, 9) @*)
= applyN incr 0 10

let summary x n
(*@ Norm(emp, x+n) @*)
= applyN incr x n

let summary1_false x n
(*@ ex r4; Norm(r4=x+n-1/\emp, r4) @*)
= applyN incr x n

let summary2_false x n
(*@ ex r4; Norm(r4=x+n+1/\emp, r4) @*)
= applyN incr x n">src/examples/applyN.ml</option><option value=src/examples/closure.ml data-text="
let closures ()
(*@ ex i; Norm(i->[8;7;42], [8;7;42]) @*)
= let l = ref [] in
  l := 42 :: !l;
  let f i = l := i :: !l in
  let g h x = h x; l := (x+1) :: !l in
  g f 7;
  (* assert (!l = [8;7;42]); *)
  !l

let closures_with_local_state ()
(*@ ex i j; Norm(i->1 * j->2, 3) @*)
= let f =
    let x = ref 0 in
    fun () -> x := !x + 1; !x
  in
  let g =
    let x = ref 0 in
    fun () -> x := !x + 2; !x
  in
  f () + g ()

let simple_closures ()
(*@ Norm(emp, 4) @*)
= let counter =
    let x = ref 0 in
    fun () -> let r = !x in x := !x + 1; r
  in
  let x = ref 3 in
  counter ();
  counter () + !x

(* Section 2.2.1 in Modular Specification and Verification of Closures in Rust *)
let closure_with_effects ()
(*@ ex i j; ens i->2*j->3/\res=5 @*)
= let i = ref 1 in
  let j = ref 2 in
  let cl x
  (*@
    ex a b; req x->a*j->b; ens j->b+a * x->a+1 /\  res=b+a+a+1
    \/ ex a; req x->a /\ x=j; ens j->a+a+1 /\ res=a+a+1+a+1
  @*)
  = j := !j + !x;
    x := !x + 1;
    !j + !x in
  cl i

(* Section 3.2 in Modular Specification and Verification of Closures in Rust *)
let closure_with_history_invariant i j
(*@ ex iv jv; req i->iv*j->jv; ens i->1*j->2 @*)
= let count = ref 0 in
  let cl ()
  (*@ ex a; req count->a; ens count->a+1/\res=a+1 @*)
  = count := !count + 1;
    !count in
  i := cl();
  j := cl()

(* Section 3.3 in Modular Specification and Verification of Closures in Rust *)
let roll_dice () (*@ ens res>0 @*) = 4 (* FIXME: Should be random *)
let call_ret f
(*@ req f <: (fun v r (*@ req v>0; ens r>0 @*)) @*)
= let x = roll_dice () in f x

let closure_with_hof_false ()
(*@ ens T @*)
= let x = ref (-1) in
  let cl i = let r = !x in x := !x + i; r in
  (* x is still -1 *)
  call_ret cl

let closure_with_hof_ok ()
= let x = ref (-1) in
  let cl i = let r = !x in x := !x + i; r in
  cl 2; (* x is now 1 *)
  call_ret cl

(* https://ilyasergey.net/CS6217/_static/slides/04-FunLog.pdf *)
let min_max_plus x y min max
(*@ ex a b; req min->a*max->b; ex i j; ens min->i*max->j/\i<=j/\res=x+y @*)
= let min' = if x < y then x else y in
  let max' = if x < y then y else x in
  min := min';
  max := max';
  x + y">src/examples/closure.ml</option><option value=src/examples/compose.ml data-text="
let compose f g x = f (g x)

let f x = x := !x + 1; x

let g x = x := !x + !x; x

let caller1 () 
(*@ ex w; Norm(w->3, 3) @*)
= let x = ref 1 in
  let y1 = compose f g x in
  !y1

let caller2 ()
(*@ ex w; Norm(w->4, 4) @*)
= let y = ref 1 in 
  let y1 = compose g f y in
  !y1">src/examples/compose.ml</option><option value=src/examples/exception.ml data-text="
let failing x
(*@ ex i; req x->i; ex r; E(x->i+1 /\ i+1=3, r)
  \/
   ex i; req x->i; ens x->i+1 /\ res=i+1 /\ ~i+1=3 @*)
= x := !x + 1;
  if !x = 3 then perform E else !x

let main ()
(*@ ex y; ens y->3 /\ res=1 @*)
= let y = ref 2 in
  match failing y with
  | effect E k -> 1
  | v -> v">src/examples/exception.ml</option><option value=src/examples/fold.ml data-text="
let rec foldr f li acc =
  match li with 
  | [] -> acc 
  | x :: xs -> 
    let acc' = f x acc in 
    foldr f xs acc'

let rec sum li = 
  match li with 
  | [] -> 0
  | x :: xs -> x + sum xs

let foldr_sum xs k
(*@ ex r; sum(xs, r); ens res=r+k @*)
= let g c t = c + t in
  foldr g xs k

let rec length li = 
  match li with 
  | [] -> 0
  | x :: xs -> 1 + length xs  

let foldr_length xs init
(*@ ex r; length(xs, r); ens res=r+init @*)
= let g c t = 1 + t in
  foldr g xs init

let foldr_length_state x xs init
(*@ ex i; req x->i; ex r; length(xs, r); ens x->i+r/\res=r+init @*)
= let g c t = x := !x + 1; 1 + t in
  foldr g xs init

let foldr_sum_state x xs init
(*@ ex i; req x->i; ex r; sum(xs, r); ens x->i+r/\res=r+init @*)
= let g c t = x := !x + c; c + t in
  foldr g xs init">src/examples/fold.ml</option><option value=src/examples/iter.ml data-text="let rec integers x n =
  if n = 0 then []
  else x :: integers (x + 1) (n - 1)

let rec fill_list f n =
  if n = 0 then []
  else f () :: fill_list f (n - 1)

(* this cannot be proved because fill_list depends on i through counter,
   so the rewrite fails *)

let build_fill_false i n
(*@ ex r; integers(i, n, r) @*)
= let counter =
    let x = ref i in
    fun () ->
      let r = !x in
      x := !x + 1;
      r
  in
  fill_list counter n

(* what would work is to parameterize by the location *)

let build_fill x n
(*@ ex i; req x->i; ex r; integers(i, n, r) @*)
= let counter =
    fun () ->
      let r = !x in
      x := !x + 1;
      r
  in
  fill_list counter n">src/examples/iter.ml</option><option value=src/examples/length.ml data-text="
let rec length xs =
  match xs with
  | [] -> 0
  | x :: xs1 -> 1 + length xs1

(*@
  lemma length_positive_l xs res =
    length(xs, res) ==> ens res>=0
@*)

(*@
  lemma length_empty res =
    length([], res) ==> ens res=0
@*)

let length_positive xs
(*@ ens res>=0 @*)
= length xs">src/examples/length.ml</option><option value=src/examples/length_pure.ml data-text="
let[@pure] rec length (li:int list) : int = 
  match li with 
  | [] -> 0
  | x :: xs -> 1 + length xs

(*@
  lemma length_length xs res =
    length(xs, res) ==> ens res=length(xs)
@*)

let length_length xs
(*@ ens res=length(xs) @*)
= length xs

let rec foldr f li acc =
  match li with 
  | [] -> acc 
  | x :: xs -> 
    let acc' = f x acc in 
    foldr f xs acc'

let foldr_length xs init
(*@ ex r; ens res=length(xs)+init @*)
= let g c t = 1 + t in
  foldr g xs init">src/examples/length_pure.ml</option><option value=src/examples/list.ml data-text="  
let rec subsequence sub lst =
  match sub with
  | [] -> true
  | y :: ys -> match lst with
    | [] -> false
    | x :: xs -> (x = y && subsequence ys xs) || subsequence sub xs

let rec replace lst x y =
  match lst with
  | [] -> []
  | h :: tail -> if h = x then y :: replace tail x y else h :: replace tail x y

let rec interleave xs ys =
  match xs with
  | [] -> ys
  | x :: xs' -> match ys with
  | [] -> xs
  | y :: ys' -> x :: (y :: interleave xs' ys')


(* OCaml List Module: https://v2.ocaml.org/api/List.html *)

(* https://v2.ocaml.org/api/List.html#VALfind_index *)
let rec find_index lst y =
  match lst with
  | [] -> 0
  | x :: xs -> if x = y then 0 else 1 + (find_index xs y)

(* https://v2.ocaml.org/api/List.html#VALexists *)
let rec exists lst f =
  match lst with
  | [] -> false
  | x :: xs -> f x || exists xs f

(* https://v2.ocaml.org/api/List.html#VALint *)
let init len f =
  if len < 0 then perform Invalid_argument;
  let rec aux idx
  = if idx = len then []
    else let k = f idx in k :: aux (idx + 1)
  in
  aux 0

(* https://v2.ocaml.org/api/List.html#VALequal *)
let rec equal xs ys =
  match xs with
  | [] -> (
    match ys with
    | [] -> true
    | y :: ys' -> false
  )
  | x :: xs' -> (
    match ys with
    | [] -> false
    | y :: ys' -> x = y && equal xs' ys'
  )">src/examples/list.ml</option><option value=src/examples/map.ml data-text="
let rec map f xs =
  match xs with
  | [] -> []
  | x :: xs1 -> f x :: map f xs1

let id y = y

let map_id ys
(*@ ens res=ys @*)
= map id ys

let succ x = x + 1

let map_not_id_false ys
(*@ ens res=ys @*)
= map succ ys

(* ghost function that specifies what mapping succ should return *)
let rec succ_list xs =
  match xs with
  | [] -> []
  | x :: xs1 -> succ x :: succ_list xs1

(* we use succ_list in the statement of this lemma *)
let map_succ ys
(*@ ex r; succ_list(ys, r); ens res=r @*)
= map succ ys

let rec length xs =
  match xs with
  | [] -> 0
  | x :: xs1 -> 1 + length xs1

let cl_map xs x
(*@ ex i; req x->i; ex r; length(xs, r); ex r1; ens x->i+r/\r1=xs/\res=r1 @*)
= let f a = x := !x + 1; a in
  map f xs

(*

Proof:

forall xs, x, res,
map(f, xs, res)
==>
ex i r; req x->i; length(xs, r); ens x->i+r /\ res=xs

[unfold map, then focus on base case, then recursive case]

----

Base case:

req emp; ens xs=[] /\ res=xs ==> ...

[unfold length on the right, pick the base case]

... ==> ex i; req x->i; ex r; ens x->i+r /\ xs=[] /\ r=0 /\ res=xs

[VCs]

x->i ==> emp * x->i

x->i * xs=[] /\ res=xs ==> ex r; ens x->i+r /\ xs=[] /\ r=0 /\ res=xs

----

Inductive case:

ex r hd tl; ens xs=hd::tl;
f(hd, r);
ex r1; map(f, tl, r1); ens res=r::r1
==>
ex i; req x->i; ex r; length(xs, r);
ens x->i+r /\ res=xs

[unfold f]

ex r hd tl; ens xs=hd::tl;
ex j; req x->j; ens x->j+1 /\ r=hd;
ex r1; map(f, tl, r1); ens res=hd::r1
==>
...

[unfold length on the right and choose the inductive case]

...
==>
ex i; req x->i; ex r;
ex lr xst; ens xs=_::xst; length(xst, lr); ens r=1+lr;
ens x->i+r /\ res=xs

[rewrite with IH]

ex r hd tl; ens xs=hd::tl;
ex j; req x->j; ens x->j+1 /\ r=hd;
ex r1;
ex i1 r2; req x->i1; length(tl, r2); ens x->i1+r2 /\ r1=tl;
ens res=hd::r1
==>
...

[norm using biabduction]

ex j; req x->j;
ex hd tl; ex r; ens xs=hd::tl /\ i1=j+1 /\ r=hd;
ex r1;
ex i1 r2; length(tl, r2); ens x->i1+r2 /\ r1=tl /\ res=hd::r1
==>
ex i; req x->i;
ex r; ex lr xst; ens xs=_::xst; length(xst, lr); ens r=1+lr /\ x->i+r /\ res=xs



*)

(* this cannot be proved because the final stage doesn't match after one unfolding *)
let cl_map_1_false ()
(*@ ens res=0 @*)=
  let y = ref 0 in
  cl_map [] y;
  !y

(* this cannot be proved because we bound the number of unfoldings.
   we could fully unfold if given finite constants perhaps *)
let cl_map_12_false ()
(*@ ens res=2 @*)=
  let y = ref 0 in
  cl_map [1;2] y;
  !y

let rec incr_list init li =
  match li with 
  | [] -> []
  | x :: xs -> 
    init :: incr_list (init + 1) xs

(* Adapted from https://github.com/FabianWolff/closure-examples/blob/master/map_vec.rs *)
let cl_map_incr_l xs x
(*@ ex i; req x->i; ex r; length(xs, r); ex r1; ens x->i+r/\res=r1 @*)
= let f a = x := !x + 1; !x in
  map f xs

let cl_map_incr_c xs x
(*@ ex i; req x->i; ex ys; ex j; ens j=i+1; incr_list(j, xs, ys); ens res=ys @*)
= let f a = x := !x + 1; !x in
  map f xs

(* Adapted from https://github.com/FabianWolff/closure-examples/blob/master/map_vec.rs *)
let rec thrice_list xs =
  match xs with
  | [] -> []
  | x :: xs' -> (x + x + x) :: thrice_list xs'

let map_thrice xs
(*@ ex ys; thrice_list(xs, ys); ens res=ys @*)
= let cl i = i + i + i in
  map cl xs">src/examples/map.ml</option><option value=src/examples/nth.ml data-text="
(*
   
nth(xs,n,r) =
 ens xs=x:xs'/\n=0/\res=x
 \/ ens xs=x:xs'/\n>0;nth(xs',n-1,res))
 \/ ens n<0; Failure()
 \/ ens xs=[]/\n>0; Invalid_argument()

*)

(*

ex v3; Invalid_argument((n<0)=true, (), v3); Norm(res=v3)
\/
ex v18 v20; ens (n<0)=false/\v20=lambda(\l n v17 -> ex v8; Failure(is_nil(l)=true, (), v8); Norm(v17=v8)); v20(l, n, v18); Norm(res=v18)

   *)

let nth l n =
  if n < 0 then perform Invalid_argument else
  let rec nth_aux l n =
    match l with
    | [] -> perform Failure
    | a::l -> if n = 0 then a else nth_aux l (n-1)
  in nth_aux l n">src/examples/nth.ml</option><option value=src/evaluation/0_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Zero(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Zero in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->0, 100)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/0_heap_zero_once_twice.ml</option><option value=src/evaluation/10_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x + 1 in 
  write y;
  read () 

let write_handler i  
(*@ 
  ex x1; Read(emp, x1); 
  ex z; req i->z; 
  ex ret; Read(i->x1+1, ret); Norm(emp, ret)
@*)
= 
  match test () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let read_handler  ()
(*@ 
  ex i; 
  Norm(i->1, 1)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write_handler i with
  | v -> v 
  | effect Read k -> 
    let x = !i in
    (continue k (x))">src/evaluation/10_memory_cell_nested.ml</option><option value=src/evaluation/11_exchange.ml data-text="effect Exchange: int -> int

let exchange (m:int)
(*@  
   ex ret;
   Exchange(emp, m, ret);
   Norm(emp, ret)
@*)
= perform (Exchange m)


let exc_hanlder y (new_v:int)
(*@  
   ex old_v; 
   req y -> old_v; 
   Norm(y -> new_v /\ res=old_v)
@*)
= match exchange new_v with 
  | v -> v 
  | effect (Exchange n) k -> 
    let old_v = !y in 
    y := n; 
    continue k old_v


let main ()
(*@  
  ex x;
  Norm(x -> 5, 11)
@*)
= 
  let x = ref 11 in 
  let r = exc_hanlder x 5 in 
  (* print_endline (string_of_int r); *)
  r">src/evaluation/11_exchange.ml</option><option value=src/evaluation/12_two_pointers.ml data-text="effect E: unit 

let two_locations () 
(*@ ex i j z1 z2 ret;
   E(i->0 * j->0, ret);
   req i->z1 * j->z2; 
   Norm(i->z1+1*j->z2+1, ret)
@*)
= let i = ref 0 in 
  let j = ref 0 in 
  let ret = perform (E) in 
  i := !i + 1;
  j := !j + 1;
  ret">src/evaluation/12_two_pointers.ml</option><option value=src/evaluation/1_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Once(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Once in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->1, 1)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> (-1)
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/1_heap_zero_once_twice.ml</option><option value=src/evaluation/2_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Twice(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Twice in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_false ()
(*@ ex i;
   Norm(i->2, 2)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/2_heap_zero_once_twice.ml</option><option value=src/evaluation/3_nestedHandlers.ml data-text="effect E : int 
effect E1 : string 

let foo () 
(*@ 
   ex ret; 
   E1(emp, ret);
   Norm(emp, ret)
@*)
= perform E1

let bar () 
(*@ 
   ex ret; 
   E1(emp, ret);
   Norm(emp, ret)
@*)
=
  match foo () with 
  | x -> x 
  | effect E k -> assert false

let baz () 
(*@ 
   Norm(emp, 1)
@*)
=
  match bar () with 
  | x -> x 
  | effect E1 k -> continue k 1">src/evaluation/3_nestedHandlers.ml</option><option value=src/evaluation/4_memory_cell.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler () 
(*@ 
  ex i; 
  Norm(i->0,  0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read () with 
  | v -> v
  | effect Read k -> continue k (!i) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/4_memory_cell.ml</option><option value=src/evaluation/5_memory_cell.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n, ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler ()
(*@ 
  ex i; 
  Norm(i->0, 0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read ();read () with 
  | v -> v
  | effect Read k -> (continue k (!i)) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->20, 20)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10; write 20 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/5_memory_cell.ml</option><option value=src/evaluation/6_memory_cell_mix_handler.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test1 ()
(*@ 
  ex x2;
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  write 10;
  read ()

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x +1 in 
  write y;
  read () 

let handler () 
(*@ 
  ex i; 
  Norm(i->1,  1)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())



let handler1 () 
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test1 () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/6_memory_cell_mix_handler.ml</option><option value=src/evaluation/7_memory_cell_mix_handler.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)">src/evaluation/7_memory_cell_mix_handler.ml</option><option value=src/evaluation/8_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x2;
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= write 10;
  read () 
  

let handler1 i 
(*@ 
  ex z x3;
  req i -> z;
  Read(i ->10, x3); 
  Norm(emp, x3)
@*)
= 
  match client () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
   ex i; 
   Norm(i->10, ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> () (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/8_memory_cell_nested.ml</option><option value=src/evaluation/9_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, 10, x2); 
  Norm(emp, x2)
@*)
= read ();
  write 10

let handler1 i  
(*@ 
  ex ret ret1 z; 
  Read(emp, ret); 
  req i-> z; 
  Norm(i->10,  ())
@*)
= 
  match client () with
  | v -> ()
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
  ex i; 
  Norm(i->10,  ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> v (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/9_memory_cell_nested.ml</option><option value=src/evaluation/abort.ml data-text="effect Zero : unit

let client () 
(*@ ex r; Zero(emp, r); req F; ens F @*)
=
  perform Zero;
  assert false

let handler ()
(*@ ex r; ens r=3/\res=r @*)
=
  match client () with
  | v -> 2
  | effect Zero k -> 3

let invalid_false ()
(*@ ens F @*)
=
  match client () with
  | v -> 2
  | effect Zero k -> continue k ()">src/evaluation/abort.ml</option><option value=src/evaluation/nqueens.ml data-text="open Effect
open Effect.Deep

(* Ported from: https://github.com/effect-handlers/effect-handlers-bench/blob/d4a32ec337b77859c328a1103e195d3e4b3dcb5b/benchmarks/ocaml/001_nqueens/001_nqueens_ocaml.ml *)
let n = try int_of_string Sys.argv.(1) with _ -> 8

let rec safe queen diag xs =
  match xs with
  | [] -> true
  | q :: qs ->
      queen <> q
      && queen <> q + diag
      && queen <> q - diag
      && safe queen (diag + 1) qs

type _ Effect.t += Pick : int -> int Effect.t

exception Fail

let rec find_solution n col : int list =
  if col = 0 then []
  else
    let sol = find_solution n (col - 1) in
    let queen = perform (Pick n) in
    if safe queen 1 sol then queen :: sol else raise Fail

let queens_count n =
  match_with (find_solution n) n
    {
      retc = (fun _ -> 1);
      exnc = (function Fail -> 0 | e -> raise e);
      effc =
        (fun (type a) (e : a Effect.t) ->
          match e with
          | Pick n ->
              Some
                (fun (k : (a, _) continuation) ->
                  let rec loop i acc =
                    if i = n then continue k i + acc
                    else
                      loop (i + 1)
                        (continue (Multicont.Deep.clone_continuation k) i + acc)
                  in
                  loop 1 0)
          | _ -> None);
    }

let queens_choose n =
  match_with (find_solution n) n
    {
      retc = (fun x -> [ x ]);
      exnc = (function Fail -> [] | e -> raise e);
      effc =
        (fun (type a) (e : a Effect.t) ->
          match e with
          | Pick n ->
              Some
                (fun (k : (a, _) continuation) ->
                  let rec loop i acc : int list list =
                    if i = 1 then continue k i @ acc
                    else
                      loop (i - 1)
                        (continue (Multicont.Deep.clone_continuation k) i @ acc)
                  in
                  loop n [])
          | _ -> None);
    }

let print_all_solutions () =
  let sols = queens_choose n in
  List.iter
    (fun l ->
      List.iter (fun pos -> Printf.printf &quot;%d &quot; pos) l;
      print_endline &quot;&quot;)
    sols

let _ =
  print_all_solutions ();
  Printf.printf &quot;%d\n&quot; (queens_count n)">src/evaluation/nqueens.ml</option><option value=src/evaluation/toss.ml data-text="effect Flip : bool

let rec tossNtimeTail n 
(* tossNtimeTail(n, res) = ens n=1; Flip(res)  \/ 
                    ex r1; ens n>1; Flip(r1); ex r2; tossNtimeTail(n-1, r2); ens res=r1 && r2 *)
= match n with 
| 1 -> perform Flip
| n -> let r1 = perform Flip in 
       let r2 = tossNtimeTail (n-1) in r1 && r2

(* \phi_inv(n,acc,r) = ex w ; req counter -> w ens[r] counter -> w+(2^(n+1) -2) /\ (acc/\r=1 \/ !acc/\r=0) *)
(* lemma: ex res; tossNtimeTail(n,res); ens[acc'] acc'=(acc /\ res) catch H ⊑ ex r; \phi_inv(n,acc,r) *)

let tossHandlerTail counter n : int  (*  counter = !counter + 2^(n+1) - 2 *)
= match tossNtimeTail n with 
  | x -> if x then 1 else 0                
  | effect Flip k ->
      counter := !counter + 1;            (* increase the counter *)
      let res1 = continue (Obj.clone_continuation k) true in         (* resume with true     *)
      counter := !counter + 1;            (* increase the counter *)
      let res2 = continue k false in      (* resume with false    *)
      res1 + res2                         (* gather the results   *)
(*proof (deep):
       counter := !counter + 1; counter := !counter + (2^(n) -2;  counter := !counter + 1; counter := !counter + (2^(n) -2;  
       counter := !counter + 1 + (2^(n) -2) + 1 + (2^(n) -2) = !counter + 2^(n+1) -2
*)

(* 
lemma: ex res; tossNtimeTail(n,res); \Phi catch H ⊑ counter := !counter + 1; tossNtimeTail(n-1,res); counter := !counter + 1; tossNtimeTail(n-1,res);
proof (shallow): 
      counter := !counter + 1; tossNtimeTail(n-1,res);  counter := !counter + 1; tossNtimeTail(n-1,res);  
*)


let rec tossNtimeNonTail n 
(* tossNtimeTail(n, res) = ens n=1; Flip(res)  \/ 
                    ex r1; ens n>1; tossNtimeTail(n-1, r1); ex r2; Flip(r2); ens res=r1 && r2 *)

(* tossNtimeTail(n, res) = ens n=1; Flip(res)  \/ 
                    ex r1; ens n>1; tossNtimeTail(n-1, r1); ens counter := !counter + 2 /\ (r1\/ false) *)

= match n with 
| 1 -> perform Flip
| n -> let r1 = tossNtimeNonTail (n-1) in 
       let r2 = perform Flip in r1 && r2


(* \phi_inv'(n,acc,s,r) = ex w ; req counter -> w ens[r] counter -> w + ((2^n -1) * s) /\ (acc/\r=1 \/ !acc/\r=0) *)
(* lemma: ex res; tossNtimeNonTail(n,res); counter -> counter + s catch H ⊑ ex r; \phi_inv'(n,acc,s,r) *)


(* \phi_inv'(n,acc,r) = ex w ; req counter -> w ens[r] counter -> w + 2^(n+2)-2 /\ (acc/\r=1 \/ !acc/\r=0) *)
(* lemma: ex res; tossNtimeNonTail(n,res); counter -> counter + 2 catch H ⊑ ex r; \phi_inv'(n,acc,r) *)


let tossHandlerNonTail counter n : int   (*  counter = !counter + 2^(n+1) - 2 *)
= match tossNtimeNonTail n with 
  | x -> if x then 1 else 0                
  | effect Flip k ->
      counter := !counter + 1;            (* increase the counter *)
      let res1 = continue (Obj.clone_continuation k) true in         (* resume with true     *)
      counter := !counter + 1;            (* increase the counter *)
      let res2 = continue k false in       (* resume with false    *)
      res1 + res2                         (* gather the results   *)

(*
proof: counter := !counter + ??? ; counter := !counter + 1;   counter := !counter + 1;
       counter :=  (2^n - 1) * (2)           
       = !counter + 2^(n+1) -2
*)


(* lemma: ex res; try tossNtimeTailShallow(1,res); \phi catch H ⊑ counter -> counter + 1;  \phi; counter + 1;  \phi; *)
(* lemma: ex res; try n > 1 /\ tossNtimeTailShallow(n,res); \phi catch H ⊑ 
   counter -> counter + 1; tossNtimeTailShallow(n-1,res); \phi; counter + 1;  tossNtimeTailShallow(n-1,res);  \phi; *)

let _ = 
   let counter = ref 0 in 
   let res = tossHandlerTail counter 9 in 
   print_endline (string_of_int !counter);
   print_endline (string_of_int res);
   let counter1 = ref 0 in 
   let res = tossHandlerNonTail counter1 9 in 
   print_endline (string_of_int !counter1);
   print_endline (string_of_int res)">src/evaluation/toss.ml</option>
        </select>
        <button id="share-btn" disabled onclick="share()">Share</button>
        <span style="display: inline-block">
          <!-- prevent the checkbox and label from wrapping separately -->
          <input type="checkbox" id="debug" style="vertical-align: middle" />
          <label for="debug" style="vertical-align: middle">Debug</label>
        </span>
      </div>
      <div id="output"></div>
    </div>
    <script type="text/javascript">
      const redirect_output = true;
      if (redirect_output) {
        const field = document.querySelector("#output");
        window.console = new Proxy(console, {
          get(_target, prop, _receiver) {
            let args = [...arguments];
            // old_console.warn(args);
            if (prop === "log") {
              return (...args) => {
                // field.value += args.join(' ') + '\n';
                field.innerHTML +=
                  '<div class="output-line">' +
                  args
                    .join(" ")
                    .replace(/\n/g, '</div><div class="output-line">') +
                  "</div>";
                // field.textContent += args.join(" ");
                // old_console.log(...args);
              };
            } else {
              return Reflect.get(...arguments);
            }
          },
        });
      }
    </script>
    <script src="coi-serviceworker.min.js"></script>
    <!-- z3-built has to be deferred -->
    <script type="text/javascript" src="z3-built.js"></script>
    <script type="text/javascript" src="ace_ocaml.js"></script>
    <script>
      // this is substituted at build time and is used in page.js
      function postExampleLoad() {
        console.log("Built Mon Nov  4 10:16:12 +08 2024");
        console.log("loading z3...");
      }
    </script>
    <script type="text/javascript" src="page.js"></script>
    <!-- hipjs logs to the console (page) -->
    <script type="text/javascript" src="hipjs.bc.js"></script>
    <!-- bundle.js/main.js requires ocaml_ready (hipjs) and enable_buttons (page) to be defined -->
    <script type="text/javascript" src="bundle.js"></script>
  </body>
</html>
