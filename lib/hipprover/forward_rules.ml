
open Hipcore
open Hiptypes
open Hipcore_typed
open Typedhip
open Untypehip
open Variables
open Pretty
open Debug
open Utils
open Syntax

(*
open Normalize
include Subst

let concatenateSpecsWithEvent (current:disj_spec) (event:spec) : disj_spec =
  List.map (fun a -> List.append a event) current

let concatenateEventWithSpecs  (event:spec) (current:disj_spec) : disj_spec =
  List.map (fun a -> List.append event a ) current


let concatenateSpecsWithSpec (current:disj_spec) (event:disj_spec) :  disj_spec =
  List.concat_map (fun a -> concatenateSpecsWithEvent current a) event

let rec retrieve_return_value (spec:spec) : term =
  match spec with
  | [] -> failwith "retrieve_return_value empty spec"
  | [NormalReturn (pi, _)] -> get_res_value_exn pi
  | [HigherOrder (_, _, _, retN)]
  | [RaisingEff(_, _, _, retN)] -> retN
  | _ :: xs -> retrieve_return_value xs

let get_lambda_return_value (d:disj_spec) : term option =
  let vals = List.concat_map (fun s ->
    try
      [retrieve_return_value s]
    with Failure _ -> []) d
  in
  match vals with
  | [] -> None
  | v :: vs when List.for_all ((=) v) vs -> Some v
  | _ :: _ -> None

let create_lambda_term ?(lid=verifier_getAfreeVar "lambda") ?body params spec =
  let ret = verifier_getAfreeVar "res" in
  let spec = instantiateSpecList ["res", Var ret] spec in
  TLambda (lid, params @ [ret], spec, body)

let rec replace_return_value (t:term) (spec:spec) : spec =
  match spec with
  | [] -> failwith "replace_return_value empty spec"
  | [HigherOrder (p, h, i, _)] -> [HigherOrder (p, h, i, t)]
  | [NormalReturn (p, h)] -> [NormalReturn (p, h)]
  | [RaisingEff(p, h, i, _)] -> [RaisingEff (p, h, i, t)]
  | s :: ss -> s :: replace_return_value t ss
*)

(** Environment used for forward verification *)
type fvenv = {
  (* defined methods, may be added to if lambdas are given names *)
  fv_methods : meth_def SMap.t;
  fv_predicates : pred_def SMap.t;
  (* proof obligations generated by defining lambdas with specifications.
     we propagate them out instead of checking them immediately to avoid a
     cyclic dependency with entailment. *)
  fv_lambda_obl : lambda_obligation list;
  fv_current_binding : string option;
}

(*
let string_of_fvenv env =
  Format.asprintf "methods: %s\n\npredicates: %s\n\nlambda obligations: %s\n\nmatch obligations: %s\n\nmatch summary: %s"
  (string_of_smap string_of_meth_def env.fv_methods)
  (string_of_smap string_of_pred env.fv_predicates)
  (string_of_list string_of_lambda_obl env.fv_lambda_obl)
  (string_of_list (string_of_pair string_of_disj_spec string_of_disj_spec) env.fv_match_obl)
  "<nyi>"
*)

let create_fv_env fv_methods fv_predicates = {
  fv_methods;
  fv_predicates;
  fv_lambda_obl = [];
  fv_current_binding = None;
}

(*
let maybe_add_local_predicate_defn x phi1 env =
  match get_lambda_return_value phi1 with
  | Some (TLambda (name, params, spec, _body)) ->
    (* predicate don't have an explicit res param, so get rid of it... *)
    let params, res = unsnoc params in
    let spec_res = instantiateSpecList [res, Var "res"] spec in
    let pred =
      {
        p_name = name;
        p_rec = (find_rec name)#visit_disj_spec () spec;
        p_params = params;
        p_body = spec_res;
      }
    in
    { env with fv_predicates = SMap.add x pred env.fv_predicates }
  | Some _ | None -> env

let retrieveSpecFromEnv (fname: string) (env:fvenv) : (string list * spec list) option =
  (* Format.printf "ENV %s@." (string_of_smap string_of_meth_def env.fv_methods); *)
  match
    SMap.find_opt fname env.fv_methods
    |> Option.map (fun m ->
      (match m.m_spec with
      | None -> ()
      | Some _sp ->
        (* print_endline ("retrieveSpecFromEnv: " ^ string_of_disj_spec _sp); *)
        ()
      );
      (m.m_params, Option.get m.m_spec))
  with
  | Some res ->
    (* let (_, specs) = res in
    print_endline ("retrieveSpecFromEnv1: " ^ string_of_disj_spec specs); *)
    Some res
  | None ->

  SMap.find_opt fname env.fv_predicates
  |> Option.map (fun p -> (p.p_params, p.p_body))

let rec specContainUndefinedHO (spec:spec) (env:fvenv) : bool =
  match spec with
  | [] -> false
  | HigherOrder (_p, _k, (c, _va), _r):: xs ->
    (match retrieveSpecFromEnv c env with
    | None -> true
    | _ -> specContainUndefinedHO xs env
    )
  | TryCatch _  :: _ -> true
  | _ :: xs -> specContainUndefinedHO xs env


let retrieveMatchSummaryFromEnv (fname: string) (env:fvenv) : (string list * spec list) option =
  let records = env.fv_match_summary in

  let rec helper li =
    match li with
    | [] -> None
    | (label, (args: string list), summary) :: xs ->
      if String.compare fname label == 0 then Some (args, summary)
      else helper xs
  in helper records

(** Find the case that handles the effect [label] *)
let lookforHandlingCases ops (label:string) =
  List.find_map (fun (s, arg, spec) ->
    if String.equal s label then Some (arg, spec) else None) ops

(* let (continueationCxt: ((spec list * string * (string * core_lang) * core_handler_ops) list) ref)  = ref []  *)

(* Given the specs of the scrutinee, symbolically execute it against the handler's spec to produce a single flow, e.g.

    match A(a,r); ens res=c with
    | A d -> continue(f,g); ens res=g
    | v -> v

    first, handle A. we need [d:=a] to bind the argument in the handler branch, and [r:=f] to pass back the argument from continue.

    this gives us a flow like the following, due to deep handling:

    ens d=a /\ r=f;
      match continue(f,g) with
      | ...
    ; ens res=g

    the spec of the continue is (ens res=c), the rest of the scrutinee after A. replace the continue stage with ens res=c.

    ens d=a /\ r=f;
      match ens res=c with
      | v -> ens res=v
      | ...
    ; ens res=g

    now recursively handle the continue. the base case occurs when there are no more effects to handle. substitute [v:=c] in the value branch.
    c will then be returned from the (substituted-away) continue stage, so [res:=g], resulting in this trace.

    ens d=a /\ r=f; ens g=c; ens res=g

    the actual code below handles extra complexity such as the scrutinee having disjunction, multiple continue stages, res not being an equality (in which case "bridging" fresh variables are needed), freshening existentials

*)

let replaceContinueWithHypo (afterHandling:disj_spec) (match_summary:disj_spec option):disj_spec =
  match match_summary with
  | None -> afterHandling
  | Some ([[HigherOrder (_, _, (f, _::formal), _)]]) ->
    (*print_endline ("replaceContinueWithHypo: " ^ string_of_staged_spec (HigherOrder (p, h, (f, hd::formal), r)));
    *)
    List.map (
      fun spec ->

        let rec helper (history:spec) (specIn:spec) : spec =
          match specIn with
          | [] ->  history
          | HigherOrder (p', h', (f', hd'::actual), r') :: xs  ->
            let x = HigherOrder (p', h', (f', hd'::actual), r') in
            if String.compare f' "continue" != 0 then helper (history@[x]) xs
            else
              let newStage =HigherOrder (p', h', (f, hd'::formal), r') in
              history@[newStage]@xs

          | x :: xs -> helper( history@[x]) xs

        in
        helper [] spec

    ) afterHandling



  | _ -> failwith ("replaceContinueWithHypo not yet")

let findTheActualArg4AccTerm arg (term:term): term option =
  match term with
  | Plus (t1, t2)
  | TAnd (t1, t2)  ->
    if stricTcompareTerm t1 arg then Some t2
    else if stricTcompareTerm t2 arg then Some t1
    else None
  | _ -> None



let rec findTheActualArg4AccPure arg (pi:pi): term option =
  match pi with
  | Atomic (_, t1, t2) ->
    (match findTheActualArg4AccTerm arg t1 with
    | Some t -> Some t
    | None -> findTheActualArg4AccTerm arg t2
    )
  | And   (p1, p2)
  | Or    (p1, p2)
  | Imply (p1, p2) ->
    (match findTheActualArg4AccPure arg p1 with
    | Some t -> Some t
    | None -> findTheActualArg4AccPure arg p2
    )
  | Not    p -> findTheActualArg4AccPure arg p
  | _ -> None





let findTheActualArg4Acc_x_e_ret (arg:term) (specs:disj_spec): term =
  match normalise_spec_list specs with
  | spec_n :: _ ->
    let (allPure:pi) = getherPureFromSpec spec_n in
    (match findTheActualArg4AccPure arg allPure with
    | None  -> Num (-1) (*failwith ("can not find findTheActualArg4Acc_x_e_ret " ^ string_of_term arg)*)
    | Some t -> t
    )

  | _ -> failwith ("findTheTermAssocatiedWith_x_e_ret empty spec")

*)


let res_eq t = Atomic (EQ, var "res" ~typ:t.term_type, t)

let call_primitive fname actualArgs =
  match fname, actualArgs with
  | "+", [x1; x2] ->
    NormalReturn (res_eq (binop Plus x1 x2), EmptyHeap)
  | "-", [x1; x2] ->
    NormalReturn (res_eq (binop Minus x1 x2), EmptyHeap)
  | "*", [x1; x2] ->
    NormalReturn (res_eq (binop TTimes x1 x2), EmptyHeap)
  | "=", [x1; x2] ->
    (* let event = NormalReturn (Atomic (EQ, x1, x2), EmptyHeap, Eq (x1, x2)) in *)
    NormalReturn (res_eq (rel EQ x1 x2), EmptyHeap)
  | "not", [x1] ->
    NormalReturn (res_eq (tnot x1), EmptyHeap)
  | "&&", [x1; x2] ->
    NormalReturn (res_eq (binop TAnd x1 x2), EmptyHeap)
  | "||", [x1; x2] ->
    NormalReturn (res_eq (binop TOr x1 x2), EmptyHeap)
  | ">", [x1; x2] ->
    NormalReturn (res_eq (rel GT x1 x2), EmptyHeap)
  | "<", [x1; x2] ->
    NormalReturn (res_eq (rel LT x1 x2), EmptyHeap)
  | ">=", [x1; x2] ->
    NormalReturn (res_eq (rel GTEQ x1 x2), EmptyHeap)
  | "<=", [x1; x2] ->
    NormalReturn (res_eq (rel LTEQ x1 x2), EmptyHeap)
  | "::", [x1; x2] ->
    NormalReturn (res_eq (binop TCons x1 x2), EmptyHeap)
  | "^", [x1; x2] ->
    NormalReturn (res_eq (binop SConcat x1 x2), EmptyHeap)
  | "string_of_int", [x1] ->
    NormalReturn (res_eq (term (TApp ("string_of_int", [x1])) TyString), EmptyHeap)
  | _ ->
    failwith (Format.asprintf "unknown primitive: %s, args: %s" fname (string_of_list string_of_term actualArgs))

let rec forward (env: fvenv) (expr : core_lang): staged_spec * fvenv =
  let@ _ = Globals.Timing.(time forward) in
  let@ _ =
    span (fun r ->
      debug ~at:4 ~title:"forward" "%s\n==>\n%s"
      (string_of_core_lang expr)
      (string_of_result (fun (r, _) -> string_of_staged_spec r) r))
  in
  match expr.core_desc with
  | CValue v ->
      NormalReturn (res_eq v, EmptyHeap), env
  | CLet (x, expr1, expr2) ->
      let spec1, env = forward env expr1 in
      let spec2, env = forward env expr2 in
      Bind (x, spec1, spec2), env
  | CSequence (expr1, expr2) ->
      let spec1, env = forward env expr1 in
      let spec2, env = forward env expr2 in
      Sequence (spec1, spec2), env
  | CIfElse (p, expr1, expr2) ->
      let spec1, env = forward env expr1 in
      let spec2, env = forward env expr2 in
      let lhs = Sequence (NormalReturn (p, EmptyHeap), spec1) in
      let rhs = Sequence (NormalReturn (Not p, EmptyHeap), spec2) in
      Disjunction (lhs, rhs), env
  | CFunCall (name, args) when List.mem name primitive_functions ->
      call_primitive name args, env
  | CFunCall (name, args) ->
      HigherOrder (name, args), env
  | CRef t ->
      let x = (fresh_variable (), TConstr ("ref", [t.term_type])) in
      Exists (x, NormalReturn (res_eq (var_of_binder x), PointsTo (ident_of_binder x, t))), env
  | CWrite (x, t) ->
      let v = (fresh_variable (), t.term_type) in
      let req = Require (True, PointsTo (x, var_of_binder v)) in
      let ens = NormalReturn (True, PointsTo (x, t)) in
      ForAll (v, Sequence (req, ens)), env
  | CRead x ->
      let v = fresh_variable () in
      let t = var ~typ:expr.core_type v in
      let kappa = PointsTo (x, t) in
      let req = Require (True, kappa) in
      let ens = NormalReturn (res_eq t, kappa) in
      ForAll (binder_of_var t, (Sequence (req, ens))), env
  | CAssert (p, h) ->
      Sequence (Require (p, h), NormalReturn (True, h)), env
  | CPerform _ ->
      failwith "CPerform"
  | CMatch (_, _, discriminant, _, cases) ->
      let v = fresh_variable ~v:"match" () in
      let t = var ~typ:discriminant.core_type v in
      let discriminant_spec, env = forward env discriminant in
      let handle_case (env, past_cases) case =
        let pat = case.ccase_pat in
        let guard = Option.value case.ccase_guard ~default:ctrue in
        let body = case.ccase_expr in
        let body_spec, env = forward env body in
        let open Patterns in
        let case_spec =
          let disjuncts =
            exclude (pat, guard) past_cases
            |> List.concat_map (fun pat -> exclude pat past_cases)
            |> List.map (pi_of_pattern t)
            |> List.map (fun (free_vars, disjunct) ->
                List.fold_right (fun var spec -> Exists (var, spec)) free_vars
                (Sequence ( NormalReturn ( disjunct, EmptyHeap ), body_spec))) in
            Syntax.disj disjuncts
        in
        case_spec, (env, (pat, guard)::past_cases)
      in
  let cases_spec, (env, _) = Lists.map_state handle_case (env, []) cases in
      let disj_spec = Syntax.disj cases_spec in
      Bind (binder_of_var t, discriminant_spec, disj_spec), env
  | CResume _ ->
      failwith "CResume"
  | CLambda (params, given_spec, body) ->
      let inferred_spec, env = forward env body in
      let lambda_id = fresh_variable "lambda" in
      let spec_to_use = match given_spec with
        | None -> Some inferred_spec
        | Some _ -> given_spec
      in
      let lambda_term = lambda ~id:lambda_id params ~spec:spec_to_use None in
      let env = match given_spec with
        (* TODO: refactor into a function *)
        | None -> env
        | Some given_spec ->
            let obl : lambda_obligation = {
              lo_name = "lambda"; (* TODO: better name *)
              lo_preds = env.fv_predicates;
              lo_left = inferred_spec;
              lo_right = given_spec;
            }
            in
            {env with fv_lambda_obl = obl :: env.fv_lambda_obl}
      in
      NormalReturn (res_eq lambda_term, EmptyHeap), env
  | CShift (nz, k, expr_body) ->
      let spec_body, env = forward env expr_body in
      let x = Variables.fresh_variable ~v:"x" "continuation argument" in
      let cont_arg_type = match type_of_binder k with
        | Arrow (typ, _) -> typ
        | TVar _
        | Any -> TVar (Variables.fresh_variable ~v:"cont_typ" ())
        | _ -> failwith "continuation argument does not have function type"
      in
      let cont = NormalReturn (res_eq (var ~typ:cont_arg_type x), EmptyHeap) in
      Shift (nz, k, spec_body, (x, cont_arg_type), cont), env
  | CReset expr_body ->
      let spec_body, env = forward env expr_body in
      (* cannot infer the type here *)
      let x = Variables.fresh_variable ~v:"x" "continuation argument" in
      let cont = NormalReturn (res_eq (var x), EmptyHeap) in
      Reset (spec_body, (x, Any), cont), env
